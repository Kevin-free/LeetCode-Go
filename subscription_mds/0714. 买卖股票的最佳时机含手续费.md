## leetcode｜炒股赚大钱之有手续费

今天是 Kevin 的算法之路的第 19 天。为大家讲解 LeetCode 第 714 题，继续为大家带来「买卖股票」系列的一个变种题《买卖股票的最佳时机含手续费》前面已经讲解过几道，不了解的建议先去看看哦

todo链接



## 每日一笑

> 父亲：“你最好把成绩告诉我，如果太差就不要认我这个父亲。”
>
> 儿子：“你谁啊。”



## 题目描述

> 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。
>
> 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
>
> 返回获得利润的最大值。
>
> 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
>
> 示例 1:
>
> 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
> 输出: 8
> 解释: 能够达到的最大利润:  
> 在此处买入 prices[0] = 1
> 在此处卖出 prices[3] = 8
> 在此处买入 prices[4] = 4
> 在此处卖出 prices[5] = 9
> 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
> 注意:
>
> 0 < prices.length <= 50000.
> 0 < prices[i] < 50000.
> 0 <= fee < 50000.
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

根据套路我们知道这道题同样使用动态规划来解决。

#### 第一步：定义状态

状态 `dp[i][j]` 定义如下

第一维 `i` 表示索引为` i `的那一天（具有前缀性质，即考虑了之前天数的收益）能获得的最大利润；
第二维 `j `表示索引为` i` 的那一天是未持有股票，还是持有股票。这里 0 表示未持有股票，1 表示持有股票。



#### 第二步：状态转移方程

- 状态从未持有股票开始，到最后一天我们关心的状态依然是未持有股票；
- 每一天状态可以转移，也可以不动。

注，这道题和《买卖股票的最佳时机 II》很像，只是这道题的不同是【交易时含有手续费】，所以在卖股票的时候需要扣除一次手续费。



#### 第三步：初始化（base case）

- 如果什么都不做，`dp[0][0] = 0`；
- 如果买入股票，当前收益是负数，即 `dp[0][1] = -prices[i]`；



#### 第四步：返回值

终止的时候，输出 `dp[len - 1][0]`，因为一定有 `dp[len - 1][0]（卖了未持股） > dp[len - 1][1]（持股）`。



## 代码实现

```go
//go
func maxProfit(prices []int, fee int) int {
	length := len(prices)
	if length < 2 {
		return 0
	}

	dp := make([][2]int, length)
	dp[0][0] = 0          //【第0天】【未持股】
	dp[0][1] = -prices[0] //【第0天】【持股】

	for i := 1; i < length; i++ {
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee) // 卖股票时扣除手续费
		dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
	}

	return dp[length-1][0]
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

这里提一下，可以根据情况压缩dp，如这道题中其实不需要用数组记录每一天的利润，我们只需要用临时变量记录就行啦。可以节省空间，如下代码

```go
//go
func maxProfit(prices []int, fee int) int {
	length := len(prices)
	if length < 2 {
		return 0
	}

	dp_0_0 := 0          // 压缩dp表示 第0天未持股
	dp_0_1 := -prices[0] // 压缩dp表示 第0天持股

	for i := 1; i < length; i++ {
		dp_0_0 = max(dp_0_0, dp_0_1+prices[i]-fee) // 卖股票时扣除手续费
		dp_0_1 = max(dp_0_1, dp_0_0-prices[i])
	}

	return dp_0_0
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)