从王者荣耀的技能施放理解调度算法



今天是 Kevin 的算法之路的第 74 天。和大家分享《王者荣耀》技能施放的最佳方案，看完之后你将可以完成 LeetCode 的第 621 题《任务调度器》



## 引

想必被标题 ~~骗~~ 吸引进来的你对《王者荣耀》应该很熟悉，那么我们先以这个游戏来引出这篇文章。



![](http://goleetcode.ifree258.top/062102.jpeg)



上图中的这个角色知道是谁吧，没错，就是小乔的姐姐——大乔。不认识也没关系，这不是重点。



假设你正愉快的玩着这个英雄，现在要求你施放 3 次 A 技能，2 次 B 技能，1 次 C 技能，并且每种技能的冷却时间都是一样的 2 秒，每种技能都可以在 1 秒内完成，请问施放这些技能所需要的 **最短时间** ？



先动动你聪明的小脑袋，想想怎么用最短的时间施放完这些技能呢？



![](http://goleetcode.ifree258.top/062105.jpg)





做题可能不行，玩游戏我们必须行啊！

来，我们一步一步来思考怎么最快的放完技能 ["A","A","A","B","B","C"] ：

因为每种技能的冷却时间一样，那我们肯定是先放要求次数最多的技能对吧，

我们先放一次 A ，需要 1s，然后有 2s 冷却，

这 2s 冷却中，我们肯定不能浪费的呀，赶紧放一次 B 和 C，

正好放完 B 和 C，A 的 2s 冷却结束，我们继续放一次 A，

诶～这不又回到了最初的起点，

2s 冷却，我们当然也不能浪费，赶紧放一次 B 和 C，

又放完 B 和 C，A 的 2s 冷却结束，我们继续再放一次 A。



哦了，是不是很简单。



当然，这是技能和次数少，我们可以这样粗暴的穷举，所以下面用图解来总结出一般情形。



我们还是先以 ["A","A","A","B","B","C"] 为例：



![](http://goleetcode.ifree258.top/062103.png)



可以看出，我将总时间分为了两部分计算：

频率最高的技能次数 - 1 次之前叫做「轮回时间」（如此例中的第一次施放 A 到最后一次施放 A 之间的时间）

频率最高的不同技能数叫做「单独时间」（如此例中最后还要单独施放 1 次 A ）



当然，我们还会碰到其他情况，比如 ["A","A","A","B","B","B","C"] 这时频率最高的不同技能数是 2，改变的就是单独时间。



![](http://goleetcode.ifree258.top/062104.png)



但是我们所得出的公式是不变的：

**总时间 = (频率最高技能次数 - 1) * (n + 1) + 频率最高的不同技能数**



另外，公式算出的值可能会比技能数量小，比如  ["A","A","B","B"] 并且冷却时间为 0，此时公示算出的结果为 3 ，但显然放完 4 个技能最少是需要 4s 的。

所以，最后应该取公式算出的总时间和技能数量的最大值。



游戏玩完了，我们该进入正事了吧？



![](http://goleetcode.ifree258.top/062106.jpg)



上题！



## 题目描述

> 给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
>
> 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
>
> 你需要计算完成所有任务所需要的 最短时间 。
>
>  
>
> 示例 1：
>
> 输入：tasks = ["A","A","A","B","B","B"], n = 2
> 输出：8
> 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
>      在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
> 示例 2：
>
> 输入：tasks = ["A","A","A","B","B","B"], n = 0
> 输出：6
> 解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
> ["A","A","A","B","B","B"]
> ["A","B","A","B","A","B"]
> ["B","B","B","A","A","A"]
> ...
> 诸如此类
> 示例 3：
>
> 输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
> 输出：16
> 解释：一种可能的解决方案是：
>      A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
>
>
> 提示：
>
> 1 <= task.length <= 104
> tasks[i] 是大写英文字母
> n 的取值范围为 [0, 100]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/task-scheduler
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。





## 解题思路

如果前面的技能施放你理解了，那这里的任务调度也是一样的。



唯一需要关注的就是代码的编写，很多时候我们其实可以理清思路，但是写代码的时候手就是不听脑子的使唤。🤷🏻‍♂️





## 代码实现

```go
//go

func leastInterval(tasks []byte, n int) int {
	// 用于记录各个任务的次数，范围为26大写英文字母
	count := make([]int, 26)

	// 统计各个任务的次数
	for _, task := range tasks {
		count[task-'A']++ // 因为是 byte，需要处理
	}

	// 按次数排序，默认升序，count[25]是频率最高的
	sort.Ints(count)

	// 次数最多的任务数
	maxCount := 0

	// 统计有多少个频率最高的任务
	for i := 25; i >= 0; i-- {
		if count[i] != count[25] {
			break
		}
		maxCount++
	}

	// 公式算出的值可能会比数组的长度小，取两者中最大的那个
	return max((count[25]-1)*(n+1) + maxCount, len(tasks))
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```



```java
//java

class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] count = new int[26];
        for (int i = 0; i < tasks.length; i++) {
            count[tasks[i]-'A']++;
        }//统计词频
        Arrays.sort(count);//词频排序，升序排序，count[25]是频率最高的
        int maxCount = 0;
        //统计有多少个频率最高的字母
        for (int i = 25; i >= 0; i--) {
            if(count[i] != count[25]){
                break;
            }
            maxCount++;
        }
        //公式算出的值可能会比数组的长度小，取两者中最大的那个
        return Math.max((count[25] - 1) * (n + 1) + maxCount , tasks.length);
    }
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～





## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![](http://wesub.ifree258.top/bottomPic.png)





## 读者福利

最近有读者反馈有些算法题比较难懂，据沟通发现是缺乏一些基础知识，所以我将自己现有的资源整理出来分享给大家，其中包括【**数据结构和算法、计算机基础、Java、Python、Golang等学习视频和电子书，以及面试和项目资源**】希望能帮助到大家～

获取方法：关注我的公众号【**Kevin的学堂**】回复【**资源**】即可免费获取！

![仅供学习，禁止商用！若有侵权，联系删除！](http://goleetcode.ifree258.top/panSrc.png)





> 最后，感谢你能看到这里！
>
> 坚持原创不易，如果你觉得还不错的话，求【**点赞**】【**在看**】【**转发**】三连安排，你的支持就是我最大的动力！



![罗翔老师都说了合适的不得了 :D ](http://wesub.ifree258.top/gifBottom.gif)



## 推荐阅读

[一日一力扣｜第64天：颜色分类](https://mp.weixin.qq.com/s?__biz=MzU1NjAyOTMyMQ==&mid=2247485392&idx=1&sn=bee83ba96e32fa2a44cc8d050fad3f4f&scene=21#wechat_redirect)

[leetcode｜一道算法题错失谷歌offer](https://mp.weixin.qq.com/s?__biz=MzU1NjAyOTMyMQ==&mid=2247484163&idx=1&sn=7ddbde400765e7048b63b4eab67cd092&scene=21#wechat_redirect)

[leetcode｜智慧树下你和我](https://mp.weixin.qq.com/s?__biz=MzU1NjAyOTMyMQ==&mid=2247484419&idx=1&sn=1931e6c91a913267ad3f2a779681bbae&scene=21#wechat_redirect)

