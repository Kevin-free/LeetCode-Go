今天是 Kevin 的算法之路的第 40 天。为大家讲解 LeetCode 第 338 题，是一道关于动态规划的题目。

> 这几天比较忙，很抱歉临时断更了，虽然没有人催促，但还是多坚持一会吧，也希望有更多的小伙伴能加入一起努力~



## 每日一笑

> 外教：Kevin, do u have a girlfriend?
>
> 我：Yeah, she's from another nation.
>
> 外教：Cool! Which nation?
>
> 我：Imagination.



## 题目描述

> 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
>
> 示例 1:
>
> 输入: 2
> 输出: [0,1,1]
> 示例 2:
>
> 输入: 5
> 输出: [0,1,1,2,1,2]
> 进阶:
>
> 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
> 要求算法的空间复杂度为O(n)。
> 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/counting-bits
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

首先计算二进制数中的 1 的数目，我们就应该自然想到用「位运算」

i & (i - 1)可以去掉i最右边的一个1（如果有），因此 i & (i - 1）是比 i 小的，而且i & (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i & (i - 1)的1的个数加上1



## 代码实现

```go
//go
func countBits(num int) []int {
	res := make([]int, num+1) //初始化了res[0] = 0
  for i:=1; i <= num; i++ { //注意要从1开始，0不满足
		res[i] = res[i & (i-1)] + 1
	}
	return res
}
```

```java
//java
public int[] countBits(int num) {
  int[] res = new int[num + 1];
  for(int i = 1;i<= num;i++){ 
    res[i] = res[i & (i - 1)] + 1;
  }
  return res;
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)