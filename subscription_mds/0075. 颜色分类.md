今天是 Kevin 的算法之路的第 64 天。为大家讲解 LeetCode 第 75 题，是一道中等难度的题目。



## 每日一笑

> 你可以不和别的男生聊天吗?天气那么热我不想给你戴帽子。



## 题目描述

> 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
>
>  
>
> 进阶：
>
> 你可以不使用代码库中的排序函数来解决这道题吗？
> 你能想出一个仅使用常数空间的一趟扫描算法吗？
>
>
> 示例 1：
>
> 输入：nums = [2,0,2,1,1,0]
> 输出：[0,0,1,1,2,2]
> 示例 2：
>
> 输入：nums = [2,0,1]
> 输出：[0,1,2]
> 示例 3：
>
> 输入：nums = [0]
> 输出：[0]
> 示例 4：
>
> 输入：nums = [1]
> 输出：[1]
>
>
> 提示：
>
> n == nums.length
> 1 <= n <= 300
> nums[i] 为 0、1 或 2
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/sort-colors
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

### 快排partition

熟悉快速排序的朋友应该对这个思路不陌生

![](http://goleetcode.ifree258.top/007501.png)

#### partition ？

partition 即 划分，我们在学习 **快速排序** 的时候知道，可以选择一个标定元素（称为 pivot ，一般而言随机选择），然后通过一次扫描，把数组分成三个部分：

第 1 部分小于 pivot 元素的值；
第 2 部分等于 pivot 元素的值；
第 3 部分大于 pivot 元素的值。

我之前详细介绍过快速排序，推荐前去了解一下

todo链接



![](http://goleetcode.ifree258.top/007502.png)

所以这里对于颜色分类，我们可以使用快排的化分思路。

这道题中使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色，我们则可以将0，1，2 排序。一次遍历，

如果是0，则换到数组头；如果是2，则换到数组尾；如果是1，不做处理。

其实这里也就是将快排的 pivot 设置为了 1.



## 代码实现

```go
//go
// 理解了思想代码应该不难实现，但是要注意一些细节

func sortColors(nums []int)  {
	n := len(nums)
	i, s, e := 0, 0, n // 因为 e 设置为了 n
	for i < e { // 所以 i<e
		if nums[i] == 0 {
			nums[i], nums[s] = nums[s], nums[i]
			s++
			i++
		}else if nums[i] == 1 {
			i++
		}else {
			e-- // e为n，防止下标越界，这里要先减，在交换
			nums[i], nums[e] = nums[e], nums[i]
		}
	}
}

//func sortColors(nums []int)  {
//	n := len(nums)
//	i, s, e := 0, 0, n-1 // 也可将 e 设置为 n-1
//	for i <= e { // 所以 i可以等于e
//		if nums[i] == 0 {
//			nums[i], nums[s] = nums[s], nums[i]
//			s++
//			i++
//		}else if nums[i] == 1 {
//			i++
//		}else {
//			nums[i], nums[e] = nums[e], nums[i]
//			e-- // 因为e初值为n-1，这里就要先交换，在减
//		}
//	}
//}
```



```java
//java
import java.util.Arrays;

public class Solution {

    public void sortColors(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return;
        }

        int zero = 0;

        int two = len;
        int i = 0;
        while (i < two) {
            if (nums[i] == 0) {
                swap(nums, i, zero);
                zero++;
                i++;
            } else if (nums[i] == 1) {
                i++;
            } else {
                two--;
                swap(nums, i, two);
            }
        }
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)