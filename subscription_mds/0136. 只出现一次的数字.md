今天是 Kevin 的算法之路的第 41 天。为大家讲解 LeetCode 第 136 题，有读者反应之前分享的很多题觉得较难看不懂，那我们还是先多弄懂一些简单题吧。逐步提升，你可以的！



## 每日一笑

> 小明：“我努力起来自己都怕。”
>
> 爸爸：“那你努力啊。”
>
> 小明：“可我怕啊。”



## 题目描述

> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 说明：
>
> 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
>
> 示例 1:
>
> 输入: [2,2,1]
> 输出: 1
> 示例 2:
>
> 输入: [4,1,2,1,2]
> 输出: 4
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/single-number
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

相信大家看到这道题肯定是有思路的，比如直接查找？排序在查找？哈希表查找？

当然上述几种思路都是可行的，但是并不如意此题的「**线性时间复杂度。 你可以不使用额外空间来实现吗？**」

那该怎么办呢？ 我们仔细研读题意，发现了这么一个线索「**其余每个元素均出现两次**」，你不觉得还特意强调这一点另有含义吗？

其实这就是个突破口！——**异或运算**！

如果你知道下面几个规则，聪明的你应该也就解决了这个问题

1. 交换律：a ^ b ^ c <=> a ^ c ^ b
2. 任何数于0异或为任何数 0 ^ n => n
3. 相同的数异或为0: n ^ n => 0

`2 ^ 3 ^ 2 ^ 4 ^ 4等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3`



## 代码实现

```go
//go
func singleNumber(nums []int) int {
    res := 0
    for _, v := range nums {
        res = res ^ v
    }
    return res
}
```

```java
//java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            single ^= num;
        }
        return single;
    }
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)