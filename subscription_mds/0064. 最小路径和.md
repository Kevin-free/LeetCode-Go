今天是 Kevin 的算法之路的第 37 天。为大家讲解 LeetCode 第 64 题，是一道中等难度的动态规划的题目。



## 每日一笑

> 从前有一个小企鹅，一天他想去北极找北极熊玩，然后他游啊游啊游~
>
> 游啊游啊游~
>
> 游到了赤道
>
> 继续游啊游啊游~
>
> 游啊游啊游~
>
> 终于游到了北极
>
> 看到了一个小火柴，正在挠脑袋，突然就着了，死了
>
> 小企鹅很伤心，回南极了



## 题目描述

> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
> 说明：每次只能向下或者向右移动一步。
>
> 示例:
>
> 输入:
> [
>   [1,3,1],
>   [1,5,1],
>   [4,2,1]
> ]
> 输出: 7
> 解释: 因为路径 1→3→1→1→1 的总和最小。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/minimum-path-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

创建二维数组`dp`，与原始网格的大小相同，`dp[i][j]` 表示从左上角出发到 `(i,j)`位置的最小路径和。显然，`dp[0][0] = grid[0][0]`。对于 `dp` 中的其余元素，通过以下状态转移方程计算元素值。

- 当 `i>0` 且 `j=0` 时，`dp[i][0] = dp[i-1][0] + grid[i][0]` 即求第一行结果
- 当 `j>0` 且 `i=0` 时，`dp[0][j] = dp[0][j-1] + grid[0][j] ` 即求第一列结果
- 当 `i>0` 且`j>0` 时，`dp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]` 即求剩余结果



> 聪明的同学可能想到了这题其实无需另开一个空间，直接遍历 `grid[i][j]`修改即可，因为原 grid 矩阵元素中被覆盖为 dp 元素后（都处于当前遍历点的左上方），不会再被使用到。
>
> 这个代码就不给出了，理解了思想相信大家很容易写出的。



## 代码实现

```go
//go
func minPathSum(grid [][]int) int {
	if grid == nil || len(grid) == 0 || len(grid[0]) == 0 {
		return 0
	}
	row, col := len(grid), len(grid[0])
	dp := make([][]int, row)
    for i := 0; i < len(dp); i++ {
        dp[i] = make([]int, col)
    }
	dp[0][0] = grid[0][0]
	for i := 1; i < row; i++ {
		dp[i][0] = dp[i-1][0] + grid[i][0]
	}
	for j := 1; j < col; j++ {
		dp[0][j] = dp[0][j-1] + grid[0][j]
	}
	for i := 1; i < row; i++ {
		for j := 1; j < col; j++ {
			dp[i][j] = Min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
		}
	}
	return dp[row-1][col-1]
}

func Min(x, y int) int {
    if x < y {
        return x
    }
    return y
}
```

```java
//java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rows = grid.length, columns = grid[0].length;
        int[][] dp = new int[rows][columns];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < columns; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < columns; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[rows - 1][columns - 1];
    }
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)