今天是 Kevin 的算法之路的第 9 天。为大家讲解 LeetCode 第 104 题，是一道关于二叉树的常考题。



## 每日一笑

> 医生：“医嘱上一天吃一副药，你怎么吃了一周的量？”
>
> 病人：“我想跟病菌来个出其不意。”



## 题目描述

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> 说明: 叶子节点是指没有子节点的节点。
>
> 示例：
> 给定二叉树 [3,9,20,null,null,15,7]，
>
>         3
>        / \
>       9  20
>         /  \
>        15   7
>
> 返回它的最大深度 3 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

DFS（深度搜索优先）

> 主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底...，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。

如果我们熟悉深度搜索优先算法的话，很容易想到用此方法来解这道题。

我们从根节点开始向下遍历，如果遇到空节点，返回0；否则继续遍历左右节点，其最大深度为左右子树深度的最大值。



![](http://goleetcode.ifree258.top/010401.png)



## 代码实现

```go
// go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    lhight := maxDepth(root.Left)
    rhight := maxDepth(root.Right)
    return max(lhight, rhight) + 1
}

func max(x int, y int) int {
    if x > y {
        return x
    }else {
        return y
    }
}
```



```java
// java
class Solution {
  public int maxDepth(TreeNode root) {
    if (root == null) {
      return 0;
    } else {
      int left_height = maxDepth(root.left);
      int right_height = maxDepth(root.right);
      return java.lang.Math.max(left_height, right_height) + 1;
    }
  }
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**原创微信公众号「Kevin的学堂」**，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)