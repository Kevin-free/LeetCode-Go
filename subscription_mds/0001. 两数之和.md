leetcode｜经典力扣第一题

今天是 Kevin 的算法之路的第 20 天。为大家讲解 LeetCode 第 1 题，是一道简单但相当经典的题目。



## 每日一笑

> 玩游戏第一次坑朋友：对不起我不是故意的。
>
> 第二次坑朋友：emmm
>
> 第三次坑朋友：嘿嘿嘿
>
> 第四次坑朋友：你怎么那么坑？



## 题目描述

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
>
>  
>
> 示例:
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
> 所以返回 [0, 1]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/two-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

### 暴力法

遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。

```go
//go
func twoSum(nums []int, target int) []int {
    length := len(nums)
    ans := make([]int,0)
    for i := 0; i<length; i++ {
        for j := i+1; j<length; j++ {
            if nums[i] + nums[j] == target{
                ans = append(ans, i, j)
            }
        }
    }
    return ans
}
```

```java
//java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

**复杂度分析：**

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)



### 哈希表法

通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。

我们可以将每个元素的值和它的索引添加到哈希表中，然后在遍历时检查每个元素对应的目标元素（target - nums[i]）是否存在于表中。注意⚠️，该目标元素不能是 nums[i] 本身！

```go
//go
func twoSum(nums []int, target int) []int {
    result := make([]int, 0)
    m := make(map[int]int, length)
    for i,k := range nums{
		// 判断map中是否存在key为[target - k]的值
		if value,exist := m[target - k];exist && value != i{
			// append：尾部追加元素
			result = append(result,value)
			result = append(result, i)
		}
		m[k] = i
	}
	return result
}
```

```java
//java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)