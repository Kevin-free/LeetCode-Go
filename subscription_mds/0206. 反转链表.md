今天是 Kevin 的算法之路的第 42 天。为大家讲解 LeetCode 第 206 题，是一道简单难度的题目。



## 每日一笑

> 哈哈哈哈你这人有毒吧！缉毒民警对毒贩小张说



## 题目描述

> 反转一个单链表。
>
> 示例:
>
> 输入: 1->2->3->4->5->NULL
> 输出: 5->4->3->2->1->NULL
> 进阶:
> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/reverse-linked-list
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

### 双指针迭代

两个指针，第一个指针叫 prev，最初是指向 null 的。
第二个指针是 head 本身，然后不断遍历 head。
每次迭代到 head，都将 head 的 next 指向 prev，然后 prev 和 head 移动一位。
都迭代完了(head 变成 null 了)，prev 就是最后一个节点了。
动画演示如下：

![](https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif)



## 代码实现

```go
//go
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode
	for head != nil {
		//反转链表，注意顺序！
		next := head.Next // 先保存下一个节点，不然后面找不着
		head.Next = prev  // 当前节点指向上一个节点
		prev = head
		head = next
		// 语法性质可简写如下
		// head.Next, head, prev = prev, head.Next, head
	}
	return prev
}
```

```java
//java
class Solution {
	public ListNode reverseList(ListNode head) {
		//申请节点，pre和 cur，pre指向null
		ListNode pre = null;
		ListNode cur = head;
		ListNode tmp = null;
		while(cur!=null) {
			//记录当前节点的下一个节点
			tmp = cur.next;
			//然后将当前节点指向pre
			cur.next = pre;
			//pre和cur节点都前进一位
			pre = cur;
			cur = tmp;
		}
		return pre;
	}
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)