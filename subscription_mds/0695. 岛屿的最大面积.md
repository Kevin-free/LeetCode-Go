今天是 Kevin 的算法之路的第 70 天。为大家讲解 LeetCode 第 695 题，仍然是一道**岛屿**的题目。



## 每日一笑

> 一学生，成绩年年倒数第一，常与人打架，按领导要求老师想给学生好听一点的期末评语，怎么写啊？
>
> 该生成绩稳定，动手能力强。



## 题目描述

> 给定一个包含了一些 0 和 1 的非空二维数组 grid 。
>
> 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)
>
>  
>
> 示例 1:
>
> [[0,0,1,0,0,0,0,1,0,0,0,0,0],
>  [0,0,0,0,0,0,0,1,1,1,0,0,0],
>  [0,1,1,0,1,0,0,0,0,0,0,0,0],
>  [0,1,0,0,1,1,0,0,1,0,1,0,0],
>  [0,1,0,0,1,1,0,0,1,1,1,0,0],
>  [0,0,0,0,0,0,0,0,0,0,1,0,0],
>  [0,0,0,0,0,0,0,1,1,1,0,0,0],
>  [0,0,0,0,0,0,0,1,1,0,0,0,0]]
> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。
>
> 示例 2:
>
> [[0,0,0,0,0,0,0,0]]
> 对于上面这个给定的矩阵, 返回 0。
>
>  
>
> 注意: 给定的矩阵grid 的长度和宽度都不超过 50。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/max-area-of-island
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

岛屿问题，同样是之前的 DFS 思路，不了解的同学前去了解一下

[一日一力扣｜第68天：岛屿数量](https://mp.weixin.qq.com/s/Caa1G1uAzsnc2KUlfSV4tg)

[一日一力扣｜第69天：岛屿的周长](https://mp.weixin.qq.com/s/GYBsf5C1F_b_o2U83EETLg)

有过之前做《岛屿数量》，《岛屿周长》的经验，这次求岛屿的最大面积应该怎么做呢？

建议大家先自己动脑筋想一想，再往下看看你的想法是不是和我一样。











================思考完了吗=================











那么接下来分享我的思路。

- 同样遍历岛屿这个二维数组，如果当前数为1，则进入 DFS 遍历函数
- 每次遍历默认从1开始累加（因为从岛屿进入的DFS函数，所以必定有1面积）
- 进入后判断如果不是岛屿，则直接返回0
- 如果是岛屿，则累加面积，并将岛屿标记为0（其他值也可以，判断不是岛屿的条件对应好就行），目的同样是避免重复遍历。
- 比较并取岛屿面积的最大值



## 代码实现

```go
//go

func maxAreaOfIsland(grid [][]int) int {
	maxArea := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			if grid[i][j] == 1 {
				maxArea = max(maxArea, dfs(grid, i, j))
			}
		}
	}
	return maxArea
}

func dfs(grid [][]int, i int, j int) int {
	// 不是岛屿，返回 0
	if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) || grid[i][j] == 0 {
		return 0
	}
	// 遍历过的岛屿，标记为 0（沉岛操作）
	grid[i][j] = 0
	num := 1
	num += dfs(grid,i-1,j)
	num += dfs(grid,i+1,j)
	num += dfs(grid,i,j-1)
	num += dfs(grid,i,j+1)
	return num
}

func max(x int, y int) int {
	if x > y {
		return x
	}else {
		return y
	}
}
```



```java
//java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0; 
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {
                    res = Math.max(res, dfs(i, j, grid));
                }
            }
        } 
        return res;
    }
    private int dfs(int i, int j, int[][] grid) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == 0) { 
            return 0;
        } 
        grid[i][j] = 0;
        int num = 1;
        num += dfs(i + 1, j, grid);
        num += dfs(i - 1, j, grid);
        num += dfs(i, j + 1, grid);
        num += dfs(i, j - 1, grid);
        return num;
        
    }
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)



## 推荐阅读

[一日一力扣｜第64天：颜色分类](https://mp.weixin.qq.com/s?__biz=MzU1NjAyOTMyMQ==&mid=2247485392&idx=1&sn=bee83ba96e32fa2a44cc8d050fad3f4f&scene=21#wechat_redirect)

[leetcode｜一道算法题错失谷歌offer](https://mp.weixin.qq.com/s?__biz=MzU1NjAyOTMyMQ==&mid=2247484163&idx=1&sn=7ddbde400765e7048b63b4eab67cd092&scene=21#wechat_redirect)

[leetcode｜智慧树下你和我](https://mp.weixin.qq.com/s?__biz=MzU1NjAyOTMyMQ==&mid=2247484419&idx=1&sn=1931e6c91a913267ad3f2a779681bbae&scene=21#wechat_redirect)



## 最后福利

最近有读者反馈有些算法题比较难懂，据沟通发现是缺乏一些基础知识，所以我将自己现有的资源整理出来分享给大家，其中包括【**数据结构和算法、计算机基础、Java、Python、Golang等学习视频和电子书，以及面试和项目资源**】希望能帮助到大家～

获取方法：关注我的公众号【**Kevin的学堂**】回复【**资源**】即可免费获取！

![仅供学习，禁止商用！若有侵权，联系删除！](http://goleetcode.ifree258.top/panSrc.png)





> 最最后，原创不易，坚持更不易，若有帮助到大家，希望能【**点赞**】【**在看**】【**转发**】一波三连，你的支持就是我莫大的动力！

