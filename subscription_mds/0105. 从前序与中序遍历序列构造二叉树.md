leetcode｜从前序与中序遍历序列构造二叉树

今天是 Kevin 的算法之路的第 24 天。为大家讲解 LeetCode 第 105 题，是一道关于数组和树的题目。



## 每日一笑

> -给你十亿你会扇你妈耳光吗？
>
> -要是十亿我都没扇 她一定会扇我的。



## 题目描述

> 根据一棵树的前序遍历与中序遍历构造二叉树。
>
> 注意:
> 你可以假设树中没有重复的元素。
>
> 例如，给出
>
> 前序遍历 preorder = [3,9,20,15,7]
> 中序遍历 inorder = [9,3,15,20,7]
> 返回如下的二叉树：
>
>            3
>           / \
>          9  20
>            /  \
>           15   7
>     来源：力扣（LeetCode）
>     链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
>     著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

preorder第一个元素为root，在inorder里面找到root，在它之前的为左子树（长stopIndex），之后为右子树。preorder[1]到preorder[stopIndex]为左子树,之后为右子树，分别递归。



## 代码实现

```go
//go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }
    root := &TreeNode{preorder[0], nil, nil}
    i := 0
    // 在inorder里root的下标
    for ; i < len(inorder); i++ {
        if inorder[i] == preorder[0] {
            break
        }
    }
    // root前的长度，即左子树的长度
    stopIndex := len(inorder[:i])+1
    root.Left = buildTree(preorder[1:stopIndex], inorder[:i])
    root.Right = buildTree(preorder[stopIndex:], inorder[i+1:])
    return root
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)