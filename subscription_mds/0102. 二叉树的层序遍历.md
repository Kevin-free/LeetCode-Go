一日一力扣｜第31天：二叉树的层序遍历

今天是 Kevin 的算法之路的第 31 天。为大家讲解 LeetCode 第 102 题，是一道经典的二叉树题目。



## 每日一笑

> 陪客户在ktv唱歌，进来两位小姐，自我介绍说：“老板好，我叫卓旦，她叫卓玛。”我看两位小姐姿色挺不错的，对客户说：“你挑卓旦，我挑卓玛”，客户愣了一下，说 ：**“迎来日出送走晚霞？”**



## 题目描述

> 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
>
>  
>
> 示例：
> 二叉树：[3,9,20,null,null,15,7],
>
>         3
>        / \
>       9  20
>         /  \
>        15   7
>     
>
> 返回其层次遍历结果：
>
> ```
> [
>   [3],
>   [9,20],
>   [15,7]
> ]
> ```
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

首先我们要知道层序遍历考查的其实就是广度优先遍历（BFS），聪明的朋友肯定还知道他的孪生兄弟深度优先遍历（DFS），篇幅较长这里就不过多介绍，感兴趣的朋友请自行了解。

要想完成广度优先遍历，我们要借助队列（先进先出，后进后出）的概念。

思想 ：当队列中的队首出队的时候，要从二叉搜索树中找到它的两个孩子入队。队列出队为空的时候，就将二叉树遍历完成了。

我们再归纳一下广度优先遍历的步骤：

1、将根节点入队（入队的时候不做别的操作）；

2、队列非空，所以接下来就要出队，规则是：依次出队，只要出队的元素有孩子，左右孩子依次入队，如果没有孩子不做任何操作。



另外，由于此题的返回数据格式是封装每层，所以这里可以定义一个count计录每层的数量

用简便图解如下：

![](http://goleetcode.ifree258.top/010201.png)

## 代码实现

```go
//go 
//* Definition for a binary tree node.
type TreeNode struct {
	Val int
	Left *TreeNode
	Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
	var res [][]int
	if root == nil {
		return res
	}
	queue := make([]*TreeNode,0)
	queue = append(queue, root) // 添加到队尾，等于add()
	for len(queue) != 0 {
		count := len(queue)
		var list []int
		for count > 0 {
			node := queue[0] //取出队首，等于poll()
			queue = queue[1:] //移出队首更新队列
			list = append(list, node.Val)
			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
			count--
		}
		res = append(res, list)
	}
	return res
}
```



```java
//java
public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null)
        return new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size();
        List<Integer> list = new ArrayList<Integer>();
        while(count > 0){
            TreeNode node = queue.poll();
            list.add(node.val);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
            count--;
        }
        res.add(list);
    }
    return res;
}
```



> 郑重声明：
>
> 所展示代码已通过 LeetCode 运行通过，请放心食用～



## 在唠唠嗑

> 很多人都想养成好习惯，但大多数人却是三分钟热度。为了我们能一起坚持下去，决定制定如下计划（福利）
>
> **一起学算法，打卡领红包！**
>
> 参与方式：
>
> 关注我的**微信公众号「Kevin的学堂」**
>
> 还可「**加群**」与众多小伙伴
>
> 一起坚持，一起学习，一起更优秀！
>
> 打卡规则为：
>
> **「留言」“打卡XXX天” ➕「分享」到朋友圈**
>
> 奖励：
>
> 连续打卡 **`21`** 天，联系本人获取 **`6.6`** 元红包一个！
>
> 连续打卡 **`52`** 天，联系本人获取 **`16.6`** 元红包一个！
>
> 连续打卡 **`100`** 天，联系本人获取 **`66.6`** 元红包一个！



![长按扫码，一起进步](http://wesub.ifree258.top/wesubQRCode-2.png)